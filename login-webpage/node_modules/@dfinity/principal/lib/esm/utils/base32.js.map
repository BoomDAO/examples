{"version":3,"file":"base32.js","sourceRoot":"","sources":["../../../src/utils/base32.ts"],"names":[],"mappings":"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","sourcesContent":["// tslint:disable:no-bitwise\nconst alphabet = 'abcdefghijklmnopqrstuvwxyz234567';\n\n// Build a lookup table for decoding.\nconst lookupTable: Record<string, number> = Object.create(null);\nfor (let i = 0; i < alphabet.length; i++) {\n  lookupTable[alphabet[i]] = i;\n}\n\n// Add aliases for rfc4648.\nlookupTable['0'] = lookupTable.o;\nlookupTable['1'] = lookupTable.i;\n\n/**\n * @param input The input array to encode.\n * @returns A Base32 string encoding the input.\n */\nexport function encode(input: Uint8Array): string {\n  // How many bits will we skip from the first byte.\n  let skip = 0;\n  // 5 high bits, carry from one byte to the next.\n  let bits = 0;\n\n  // The output string in base32.\n  let output = '';\n\n  function encodeByte(byte: number) {\n    if (skip < 0) {\n      // we have a carry from the previous byte\n      bits |= byte >> -skip;\n    } else {\n      // no carry\n      bits = (byte << skip) & 248;\n    }\n\n    if (skip > 3) {\n      // Not enough data to produce a character, get us another one\n      skip -= 8;\n      return 1;\n    }\n\n    if (skip < 4) {\n      // produce a character\n      output += alphabet[bits >> 3];\n      skip += 5;\n    }\n\n    return 0;\n  }\n\n  for (let i = 0; i < input.length; ) {\n    i += encodeByte(input[i]);\n  }\n\n  return output + (skip < 0 ? alphabet[bits >> 3] : '');\n}\n\n/**\n * @param input The base32 encoded string to decode.\n */\nexport function decode(input: string): Uint8Array {\n  // how many bits we have from the previous character.\n  let skip = 0;\n  // current byte we're producing.\n  let byte = 0;\n\n  const output = new Uint8Array(((input.length * 4) / 3) | 0);\n  let o = 0;\n\n  function decodeChar(char: string) {\n    // Consume a character from the stream, store\n    // the output in this.output. As before, better\n    // to use update().\n    let val = lookupTable[char.toLowerCase()];\n    if (val === undefined) {\n      throw new Error(`Invalid character: ${JSON.stringify(char)}`);\n    }\n\n    // move to the high bits\n    val <<= 3;\n    byte |= val >>> skip;\n    skip += 5;\n\n    if (skip >= 8) {\n      // We have enough bytes to produce an output\n      output[o++] = byte;\n      skip -= 8;\n\n      if (skip > 0) {\n        byte = (val << (5 - skip)) & 255;\n      } else {\n        byte = 0;\n      }\n    }\n  }\n\n  for (const c of input) {\n    decodeChar(c);\n  }\n\n  return output.slice(0, o);\n}\n"]}