{"version":3,"file":"webauthn.js","sourceRoot":"","sources":["../../../src/identity/webauthn.ts"],"names":[],"mappings":"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","sourcesContent":["import { DerEncodedPublicKey, PublicKey, Signature, SignIdentity } from '@dfinity/agent';\nimport borc from 'borc';\nimport * as tweetnacl from 'tweetnacl';\nimport { fromHexString, toHexString } from '../buffer';\nimport { DER_COSE_OID, wrapDER } from './der';\n\nfunction _coseToDerEncodedBlob(cose: ArrayBuffer): DerEncodedPublicKey {\n  return wrapDER(cose, DER_COSE_OID).buffer as DerEncodedPublicKey;\n}\n\ntype PublicKeyCredentialWithAttachment = PublicKeyCredential & {\n  // Extends `PublicKeyCredential` with an optional field introduced in the WebAuthn level 3 spec:\n  // https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment\n  // Already supported by Chrome, Safari and Edge\n  // Note: `null` is included here as a possible value because Edge set this value to null in the\n  // past.\n  authenticatorAttachment: AuthenticatorAttachment | undefined | null;\n};\n\n/**\n * From the documentation;\n * The authData is a byte array described in the spec. Parsing it will involve slicing bytes from\n * the array and converting them into usable objects.\n *\n * See https://webauthn.guide/#registration (subsection \"Example: Parsing the authenticator data\").\n *\n * @param authData The authData field of the attestation response.\n * @returns The COSE key of the authData.\n */\nfunction _authDataToCose(authData: ArrayBuffer): ArrayBuffer {\n  const dataView = new DataView(new ArrayBuffer(2));\n  const idLenBytes = authData.slice(53, 55);\n  [...new Uint8Array(idLenBytes)].forEach((v, i) => dataView.setUint8(i, v));\n  const credentialIdLength = dataView.getUint16(0);\n\n  // Get the public key object.\n  return authData.slice(55 + credentialIdLength);\n}\n\nexport class CosePublicKey implements PublicKey {\n  protected _encodedKey: DerEncodedPublicKey;\n\n  public constructor(protected _cose: ArrayBuffer) {\n    this._encodedKey = _coseToDerEncodedBlob(_cose);\n  }\n\n  public toDer(): DerEncodedPublicKey {\n    return this._encodedKey;\n  }\n\n  public getCose(): ArrayBuffer {\n    return this._cose;\n  }\n}\n\n/**\n * Create a challenge from a string or array. The default challenge is always the same\n * because we don't need to verify the authenticity of the key on the server (we don't\n * register our keys with the IC). Any challenge would do, even one per key, randomly\n * generated.\n *\n * @param challenge The challenge to transform into a byte array. By default a hard\n *        coded string.\n */\nfunction _createChallengeBuffer(challenge: string | Uint8Array = '<ic0.app>'): Uint8Array {\n  if (typeof challenge === 'string') {\n    return Uint8Array.from(challenge, c => c.charCodeAt(0));\n  } else {\n    return challenge;\n  }\n}\n\n/**\n * Create a credentials to authenticate with a server. This is necessary in order in\n * WebAuthn to get credentials IDs (which give us the public key and allow us to\n * sign), but in the case of the Internet Computer, we don't actually need to register\n * it, so we don't.\n * @param credentialCreationOptions an optional CredentialCreationOptions object\n */\nasync function _createCredential(\n  credentialCreationOptions?: CredentialCreationOptions,\n): Promise<PublicKeyCredentialWithAttachment | null> {\n  const creds = (await navigator.credentials.create(\n    credentialCreationOptions ?? {\n      publicKey: {\n        authenticatorSelection: {\n          userVerification: 'preferred',\n        },\n        attestation: 'direct',\n        challenge: _createChallengeBuffer(),\n        pubKeyCredParams: [{ type: 'public-key', alg: PubKeyCoseAlgo.ECDSA_WITH_SHA256 }],\n        rp: {\n          name: 'Internet Identity Service',\n        },\n        user: {\n          id: tweetnacl.randomBytes(16),\n          name: 'Internet Identity',\n          displayName: 'Internet Identity',\n        },\n      },\n    },\n  )) as PublicKeyCredentialWithAttachment;\n\n  // Validate that it's the correct type at runtime, since WebAuthn does not HAVE to\n  // reply with a PublicKeyCredential.\n  if (creds.response === undefined || !(creds.rawId instanceof ArrayBuffer)) {\n    return null;\n  } else {\n    return creds;\n  }\n}\n\n// See https://www.iana.org/assignments/cose/cose.xhtml#algorithms for a complete\n// list of these algorithms. We only list the ones we support here.\nenum PubKeyCoseAlgo {\n  ECDSA_WITH_SHA256 = -7,\n}\n\n/**\n * A SignIdentity that uses `navigator.credentials`. See https://webauthn.guide/ for\n * more information about WebAuthentication.\n */\nexport class WebAuthnIdentity extends SignIdentity {\n  /**\n   * Create an identity from a JSON serialization.\n   * @param json - json to parse\n   */\n  public static fromJSON(json: string): WebAuthnIdentity {\n    const { publicKey, rawId } = JSON.parse(json);\n\n    if (typeof publicKey !== 'string' || typeof rawId !== 'string') {\n      throw new Error('Invalid JSON string.');\n    }\n\n    return new this(fromHexString(rawId), fromHexString(publicKey), undefined);\n  }\n\n  /**\n   * Create an identity.\n   * @param credentialCreationOptions an optional CredentialCreationOptions Challenge\n   */\n  public static async create(\n    credentialCreationOptions?: CredentialCreationOptions,\n  ): Promise<WebAuthnIdentity> {\n    const creds = await _createCredential(credentialCreationOptions);\n\n    if (!creds || creds.type !== 'public-key') {\n      throw new Error('Could not create credentials.');\n    }\n\n    const response = creds.response as AuthenticatorAttestationResponse;\n    if (!(response.attestationObject instanceof ArrayBuffer)) {\n      throw new Error('Was expecting an attestation response.');\n    }\n\n    // Parse the attestationObject as CBOR.\n    const attObject = borc.decodeFirst(new Uint8Array(response.attestationObject));\n\n    return new this(\n      creds.rawId,\n      _authDataToCose(attObject.authData),\n      creds.authenticatorAttachment ?? undefined,\n    );\n  }\n\n  protected _publicKey: CosePublicKey;\n\n  public constructor(\n    public readonly rawId: ArrayBuffer,\n    cose: ArrayBuffer,\n    protected authenticatorAttachment: AuthenticatorAttachment | undefined,\n  ) {\n    super();\n    this._publicKey = new CosePublicKey(cose);\n  }\n\n  public getPublicKey(): PublicKey {\n    return this._publicKey;\n  }\n\n  /**\n   * WebAuthn level 3 spec introduces a new attribute on successful WebAuthn interactions,\n   * see https://w3c.github.io/webauthn/#dom-publickeycredential-authenticatorattachment.\n   * This attribute is already implemented for Chrome, Safari and Edge.\n   *\n   * Given the attribute is only available after a successful interaction, the information is\n   * provided opportunistically and might also be `undefined`.\n   */\n  public getAuthenticatorAttachment(): AuthenticatorAttachment | undefined {\n    return this.authenticatorAttachment;\n  }\n\n  public async sign(blob: ArrayBuffer): Promise<Signature> {\n    const result = (await navigator.credentials.get({\n      publicKey: {\n        allowCredentials: [\n          {\n            type: 'public-key',\n            id: this.rawId,\n          },\n        ],\n        challenge: blob,\n        userVerification: 'preferred',\n      },\n    })) as PublicKeyCredentialWithAttachment;\n\n    if (result.authenticatorAttachment !== null) {\n      this.authenticatorAttachment = result.authenticatorAttachment;\n    }\n\n    const response = result.response as AuthenticatorAssertionResponse;\n    if (\n      response.signature instanceof ArrayBuffer &&\n      response.authenticatorData instanceof ArrayBuffer\n    ) {\n      const cbor = borc.encode(\n        new borc.Tagged(55799, {\n          authenticator_data: new Uint8Array(response.authenticatorData),\n          client_data_json: new TextDecoder().decode(response.clientDataJSON),\n          signature: new Uint8Array(response.signature),\n        }),\n      );\n      if (!cbor) {\n        throw new Error('failed to encode cbor');\n      }\n      return cbor.buffer as Signature;\n    } else {\n      throw new Error('Invalid response from WebAuthn.');\n    }\n  }\n\n  /**\n   * Allow for JSON serialization of all information needed to reuse this identity.\n   */\n  public toJSON(): JsonnableWebAuthnIdentitiy {\n    return {\n      publicKey: toHexString(this._publicKey.getCose()),\n      rawId: toHexString(this.rawId),\n    };\n  }\n}\n\n/**\n * ReturnType<WebAuthnIdentity.toJSON>\n */\nexport interface JsonnableWebAuthnIdentitiy {\n  // The hexadecimal representation of the DER encoded public key.\n  publicKey: string;\n  // The string representation of the local WebAuthn Credential.id (base64url encoded).\n  rawId: string;\n}\n"]}