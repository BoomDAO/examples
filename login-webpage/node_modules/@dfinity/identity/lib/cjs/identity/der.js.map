{"version":3,"file":"der.js","sourceRoot":"","sources":["../../../src/identity/der.ts"],"names":[],"mappings":";;;AAAO,MAAM,SAAS,GAAG,CAAC,EAAe,EAAE,EAAe,EAAW,EAAE;IACrE,IAAI,EAAE,CAAC,UAAU,KAAK,EAAE,CAAC,UAAU;QAAE,OAAO,KAAK,CAAC;IAClD,MAAM,EAAE,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC;IAC9B,MAAM,EAAE,GAAG,IAAI,UAAU,CAAC,EAAE,CAAC,CAAC;IAC9B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QAClC,IAAI,EAAE,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;YAAE,OAAO,KAAK,CAAC;KACnC;IACD,OAAO,IAAI,CAAC;AACd,CAAC,CAAC;AARW,QAAA,SAAS,aAQpB;AAEK,MAAM,cAAc,GAAG,CAAC,GAAW,EAAU,EAAE;IACpD,IAAI,GAAG,IAAI,IAAI,EAAE;QACf,OAAO,CAAC,CAAC;KACV;SAAM,IAAI,GAAG,IAAI,IAAI,EAAE;QACtB,OAAO,CAAC,CAAC;KACV;SAAM,IAAI,GAAG,IAAI,MAAM,EAAE;QACxB,OAAO,CAAC,CAAC;KACV;SAAM,IAAI,GAAG,IAAI,QAAQ,EAAE;QAC1B,OAAO,CAAC,CAAC;KACV;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;KAChD;AACH,CAAC,CAAC;AAZW,QAAA,cAAc,kBAYzB;AAEK,MAAM,SAAS,GAAG,CAAC,GAAe,EAAE,MAAc,EAAE,GAAW,EAAU,EAAE;IAChF,IAAI,GAAG,IAAI,IAAI,EAAE;QACf,GAAG,CAAC,MAAM,CAAC,GAAG,GAAG,CAAC;QAClB,OAAO,CAAC,CAAC;KACV;SAAM,IAAI,GAAG,IAAI,IAAI,EAAE;QACtB,GAAG,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;QACnB,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC;QACtB,OAAO,CAAC,CAAC;KACV;SAAM,IAAI,GAAG,IAAI,MAAM,EAAE;QACxB,GAAG,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;QACnB,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC;QAC3B,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC;QACtB,OAAO,CAAC,CAAC;KACV;SAAM,IAAI,GAAG,IAAI,QAAQ,EAAE;QAC1B,GAAG,CAAC,MAAM,CAAC,GAAG,IAAI,CAAC;QACnB,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,IAAI,EAAE,CAAC;QAC5B,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,CAAC;QAC3B,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,GAAG,CAAC;QACtB,OAAO,CAAC,CAAC;KACV;SAAM;QACL,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;KAChD;AACH,CAAC,CAAC;AAtBW,QAAA,SAAS,aAsBpB;AAEK,MAAM,cAAc,GAAG,CAAC,GAAe,EAAE,MAAc,EAAU,EAAE;IACxE,IAAI,GAAG,CAAC,MAAM,CAAC,GAAG,IAAI;QAAE,OAAO,CAAC,CAAC;IACjC,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,IAAI;QAAE,MAAM,IAAI,KAAK,CAAC,kBAAkB,CAAC,CAAC;IAC9D,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,IAAI;QAAE,OAAO,CAAC,CAAC;IACnC,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,IAAI;QAAE,OAAO,CAAC,CAAC;IACnC,IAAI,GAAG,CAAC,MAAM,CAAC,KAAK,IAAI;QAAE,OAAO,CAAC,CAAC;IACnC,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;AACjD,CAAC,CAAC;AAPW,QAAA,cAAc,kBAOzB;AAEK,MAAM,SAAS,GAAG,CAAC,GAAe,EAAE,MAAc,EAAU,EAAE;IACnE,MAAM,QAAQ,GAAG,IAAA,sBAAc,EAAC,GAAG,EAAE,MAAM,CAAC,CAAC;IAC7C,IAAI,QAAQ,KAAK,CAAC;QAAE,OAAO,GAAG,CAAC,MAAM,CAAC,CAAC;SAClC,IAAI,QAAQ,KAAK,CAAC;QAAE,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;SAC3C,IAAI,QAAQ,KAAK,CAAC;QAAE,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;SACpE,IAAI,QAAQ,KAAK,CAAC;QACrB,OAAO,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC,GAAG,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAC5E,MAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;AACjD,CAAC,CAAC;AARW,QAAA,SAAS,aAQpB;AAEF;;GAEG;AACU,QAAA,YAAY,GAAG,UAAU,CAAC,IAAI,CAAC;IAC1C,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACf,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACf,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,mBAAmB;CACrF,CAAC,CAAC;AAEH;;GAEG;AACU,QAAA,WAAW,GAAG,UAAU,CAAC,IAAI,CAAC;IACzC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACf,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACf,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,iBAAiB;CACzC,CAAC,CAAC;AAEH;;GAEG;AACU,QAAA,aAAa,GAAG,UAAU,CAAC,IAAI,CAAC;IAC3C,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACf,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACf,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;IAC7C,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC;IACf,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,EAAE,gBAAgB;CACpD,CAAC,CAAC;AAEH;;;;;;GAMG;AACH,SAAgB,OAAO,CAAC,OAAoB,EAAE,GAAe;IAC3D,iFAAiF;IACjF,MAAM,qBAAqB,GAAG,CAAC,GAAG,IAAA,sBAAc,EAAC,OAAO,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IACzE,MAAM,GAAG,GAAG,GAAG,CAAC,UAAU,GAAG,qBAAqB,GAAG,OAAO,CAAC,UAAU,CAAC;IACxE,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,CAAC,GAAG,IAAA,sBAAc,EAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC;IAC1D,WAAW;IACX,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC;IACrB,kBAAkB;IAClB,MAAM,IAAI,IAAA,iBAAS,EAAC,GAAG,EAAE,MAAM,EAAE,GAAG,CAAC,CAAC;IAEtC,MAAM;IACN,GAAG,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;IACrB,MAAM,IAAI,GAAG,CAAC,UAAU,CAAC;IAEzB,oBAAoB;IACpB,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC;IACrB,MAAM,IAAI,IAAA,iBAAS,EAAC,GAAG,EAAE,MAAM,EAAE,OAAO,CAAC,UAAU,GAAG,CAAC,CAAC,CAAC;IACzD,YAAY;IACZ,GAAG,CAAC,MAAM,EAAE,CAAC,GAAG,IAAI,CAAC;IACrB,GAAG,CAAC,GAAG,CAAC,IAAI,UAAU,CAAC,OAAO,CAAC,EAAE,MAAM,CAAC,CAAC;IAEzC,OAAO,GAAG,CAAC;AACb,CAAC;AAvBD,0BAuBC;AAED;;;;;;;;GAQG;AACI,MAAM,SAAS,GAAG,CAAC,UAAuB,EAAE,GAAe,EAAc,EAAE;IAChF,IAAI,MAAM,GAAG,CAAC,CAAC;IACf,MAAM,MAAM,GAAG,CAAC,CAAS,EAAE,GAAW,EAAE,EAAE;QACxC,IAAI,GAAG,CAAC,MAAM,EAAE,CAAC,KAAK,CAAC,EAAE;YACvB,MAAM,IAAI,KAAK,CAAC,YAAY,GAAG,GAAG,CAAC,CAAC;SACrC;IACH,CAAC,CAAC;IAEF,MAAM,GAAG,GAAG,IAAI,UAAU,CAAC,UAAU,CAAC,CAAC;IACvC,MAAM,CAAC,IAAI,EAAE,UAAU,CAAC,CAAC;IACzB,MAAM,IAAI,IAAA,sBAAc,EAAC,GAAG,EAAE,MAAM,CAAC,CAAC;IAEtC,IAAI,CAAC,IAAA,iBAAS,EAAC,GAAG,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,GAAG,CAAC,UAAU,CAAC,EAAE,GAAG,CAAC,EAAE;QAC/D,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;KAC1C;IACD,MAAM,IAAI,GAAG,CAAC,UAAU,CAAC;IAEzB,MAAM,CAAC,IAAI,EAAE,YAAY,CAAC,CAAC;IAC3B,MAAM,UAAU,GAAG,IAAA,iBAAS,EAAC,GAAG,EAAE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,6CAA6C;IAC5F,MAAM,IAAI,IAAA,sBAAc,EAAC,GAAG,EAAE,MAAM,CAAC,CAAC;IACtC,MAAM,CAAC,IAAI,EAAE,WAAW,CAAC,CAAC;IAC1B,MAAM,MAAM,GAAG,GAAG,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IACjC,IAAI,UAAU,KAAK,MAAM,CAAC,MAAM,EAAE;QAChC,MAAM,IAAI,KAAK,CACb,yCAAyC,UAAU,kBAAkB,MAAM,CAAC,MAAM,EAAE,CACrF,CAAC;KACH;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AA5BW,QAAA,SAAS,aA4BpB","sourcesContent":["export const bufEquals = (b1: ArrayBuffer, b2: ArrayBuffer): boolean => {\n  if (b1.byteLength !== b2.byteLength) return false;\n  const u1 = new Uint8Array(b1);\n  const u2 = new Uint8Array(b2);\n  for (let i = 0; i < u1.length; i++) {\n    if (u1[i] !== u2[i]) return false;\n  }\n  return true;\n};\n\nexport const encodeLenBytes = (len: number): number => {\n  if (len <= 0x7f) {\n    return 1;\n  } else if (len <= 0xff) {\n    return 2;\n  } else if (len <= 0xffff) {\n    return 3;\n  } else if (len <= 0xffffff) {\n    return 4;\n  } else {\n    throw new Error('Length too long (> 4 bytes)');\n  }\n};\n\nexport const encodeLen = (buf: Uint8Array, offset: number, len: number): number => {\n  if (len <= 0x7f) {\n    buf[offset] = len;\n    return 1;\n  } else if (len <= 0xff) {\n    buf[offset] = 0x81;\n    buf[offset + 1] = len;\n    return 2;\n  } else if (len <= 0xffff) {\n    buf[offset] = 0x82;\n    buf[offset + 1] = len >> 8;\n    buf[offset + 2] = len;\n    return 3;\n  } else if (len <= 0xffffff) {\n    buf[offset] = 0x83;\n    buf[offset + 1] = len >> 16;\n    buf[offset + 2] = len >> 8;\n    buf[offset + 3] = len;\n    return 4;\n  } else {\n    throw new Error('Length too long (> 4 bytes)');\n  }\n};\n\nexport const decodeLenBytes = (buf: Uint8Array, offset: number): number => {\n  if (buf[offset] < 0x80) return 1;\n  if (buf[offset] === 0x80) throw new Error('Invalid length 0');\n  if (buf[offset] === 0x81) return 2;\n  if (buf[offset] === 0x82) return 3;\n  if (buf[offset] === 0x83) return 4;\n  throw new Error('Length too long (> 4 bytes)');\n};\n\nexport const decodeLen = (buf: Uint8Array, offset: number): number => {\n  const lenBytes = decodeLenBytes(buf, offset);\n  if (lenBytes === 1) return buf[offset];\n  else if (lenBytes === 2) return buf[offset + 1];\n  else if (lenBytes === 3) return (buf[offset + 1] << 8) + buf[offset + 2];\n  else if (lenBytes === 4)\n    return (buf[offset + 1] << 16) + (buf[offset + 2] << 8) + buf[offset + 3];\n  throw new Error('Length too long (> 4 bytes)');\n};\n\n/**\n * A DER encoded `SEQUENCE(OID)` for DER-encoded-COSE\n */\nexport const DER_COSE_OID = Uint8Array.from([\n  ...[0x30, 0x0c], // SEQUENCE\n  ...[0x06, 0x0a], // OID with 10 bytes\n  ...[0x2b, 0x06, 0x01, 0x04, 0x01, 0x83, 0xb8, 0x43, 0x01, 0x01], // DER encoded COSE\n]);\n\n/**\n * A DER encoded `SEQUENCE(OID)` for the Ed25519 algorithm\n */\nexport const ED25519_OID = Uint8Array.from([\n  ...[0x30, 0x05], // SEQUENCE\n  ...[0x06, 0x03], // OID with 3 bytes\n  ...[0x2b, 0x65, 0x70], // id-Ed25519 OID\n]);\n\n/**\n * A DER encoded `SEQUENCE(OID)` for secp256k1 with the ECDSA algorithm\n */\nexport const SECP256K1_OID = Uint8Array.from([\n  ...[0x30, 0x10], // SEQUENCE\n  ...[0x06, 0x07], // OID with 7 bytes\n  ...[0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01], // OID ECDSA\n  ...[0x06, 0x05], // OID with 5 bytes\n  ...[0x2b, 0x81, 0x04, 0x00, 0x0a], // OID secp256k1\n]);\n\n/**\n * Wraps the given `payload` in a DER encoding tagged with the given encoded `oid` like so:\n * `SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param payload The payload to encode as the bit string\n * @param oid The DER encoded (and SEQUENCE wrapped!) OID to tag the payload with\n */\nexport function wrapDER(payload: ArrayBuffer, oid: Uint8Array): Uint8Array {\n  // The Bit String header needs to include the unused bit count byte in its length\n  const bitStringHeaderLength = 2 + encodeLenBytes(payload.byteLength + 1);\n  const len = oid.byteLength + bitStringHeaderLength + payload.byteLength;\n  let offset = 0;\n  const buf = new Uint8Array(1 + encodeLenBytes(len) + len);\n  // Sequence\n  buf[offset++] = 0x30;\n  // Sequence Length\n  offset += encodeLen(buf, offset, len);\n\n  // OID\n  buf.set(oid, offset);\n  offset += oid.byteLength;\n\n  // Bit String Header\n  buf[offset++] = 0x03;\n  offset += encodeLen(buf, offset, payload.byteLength + 1);\n  // 0 padding\n  buf[offset++] = 0x00;\n  buf.set(new Uint8Array(payload), offset);\n\n  return buf;\n}\n\n/**\n * Extracts a payload from the given `derEncoded` data, and checks that it was tagged with the given `oid`.\n *\n * `derEncoded = SEQUENCE(oid, BITSTRING(payload))`\n *\n * @param derEncoded The DER encoded and tagged data\n * @param oid The DER encoded (and SEQUENCE wrapped!) expected OID\n * @returns The unwrapped payload\n */\nexport const unwrapDER = (derEncoded: ArrayBuffer, oid: Uint8Array): Uint8Array => {\n  let offset = 0;\n  const expect = (n: number, msg: string) => {\n    if (buf[offset++] !== n) {\n      throw new Error('Expected: ' + msg);\n    }\n  };\n\n  const buf = new Uint8Array(derEncoded);\n  expect(0x30, 'sequence');\n  offset += decodeLenBytes(buf, offset);\n\n  if (!bufEquals(buf.slice(offset, offset + oid.byteLength), oid)) {\n    throw new Error('Not the expected OID.');\n  }\n  offset += oid.byteLength;\n\n  expect(0x03, 'bit string');\n  const payloadLen = decodeLen(buf, offset) - 1; // Subtracting 1 to account for the 0 padding\n  offset += decodeLenBytes(buf, offset);\n  expect(0x00, '0 padding');\n  const result = buf.slice(offset);\n  if (payloadLen !== result.length) {\n    throw new Error(\n      `DER payload mismatch: Expected length ${payloadLen} actual length ${result.length}`,\n    );\n  }\n  return result;\n};\n"]}