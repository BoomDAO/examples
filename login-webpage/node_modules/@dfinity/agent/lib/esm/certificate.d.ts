import { AgentError } from './errors';
import { Principal } from '@dfinity/principal';
/**
 * A certificate may fail verification with respect to the provided public key
 */
export declare class CertificateVerificationError extends AgentError {
    constructor(reason: string);
}
declare const enum NodeId {
    Empty = 0,
    Fork = 1,
    Labeled = 2,
    Leaf = 3,
    Pruned = 4
}
export declare type HashTree = [NodeId.Empty] | [NodeId.Fork, HashTree, HashTree] | [NodeId.Labeled, ArrayBuffer, HashTree] | [NodeId.Leaf, ArrayBuffer] | [NodeId.Pruned, ArrayBuffer];
/**
 * Make a human readable string out of a hash tree.
 * @param tree
 */
export declare function hashTreeToString(tree: HashTree): string;
declare type VerifyFunc = (pk: Uint8Array, sig: Uint8Array, msg: Uint8Array) => Promise<boolean>;
export interface CreateCertificateOptions {
    /**
     * The bytes encoding the certificate to be verified
     */
    certificate: ArrayBuffer;
    /**
     * The root key against which to verify the certificate
     * (normally, the root key of the IC main network)
     */
    rootKey: ArrayBuffer;
    /**
     * The effective canister ID of the request when verifying a response, or
     * the signing canister ID when verifying a certified variable.
     */
    canisterId: Principal;
    /**
     * BLS Verification strategy. Default strategy uses wasm for performance, but that may not be available in all contexts.
     */
    blsVerify?: VerifyFunc;
}
export declare class Certificate {
    private _rootKey;
    private _canisterId;
    private _blsVerify;
    private readonly cert;
    /**
     * Create a new instance of a certificate, automatically verifying it. Throws a
     * CertificateVerificationError if the certificate cannot be verified.
     * @constructs {@link AuthClient}
     * @param {CreateCertificateOptions} options
     * @see {@link CreateCertificateOptions}
     * @param {ArrayBuffer} options.certificate The bytes of the certificate
     * @param {ArrayBuffer} options.rootKey The root key to verify against
     * @param {Principal} options.canisterId The effective or signing canister ID
     * @throws {CertificateVerificationError}
     */
    static create(options: CreateCertificateOptions): Promise<Certificate>;
    private constructor();
    lookup(path: Array<ArrayBuffer | string>): ArrayBuffer | undefined;
    private verify;
    private _checkDelegationAndGetKey;
}
/**
 * @param t
 */
export declare function reconstruct(t: HashTree): Promise<ArrayBuffer>;
/**
 * @param path
 * @param tree
 */
export declare function lookup_path(path: Array<ArrayBuffer | string>, tree: HashTree): ArrayBuffer | undefined;
export {};
