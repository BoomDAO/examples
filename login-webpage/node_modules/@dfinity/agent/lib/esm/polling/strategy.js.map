{"version":3,"file":"strategy.js","sourceRoot":"","sources":["../../../src/polling/strategy.ts"],"names":[],"mappings":"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","sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { RequestStatusResponseStatus } from '../agent';\nimport { toHex } from '../utils/buffer';\nimport { PollStrategy } from './index';\nimport { RequestId } from '../request_id';\n\nexport type Predicate<T> = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<T>;\n\nconst FIVE_MINUTES_IN_MSEC = 5 * 60 * 1000;\n\n/**\n * A best practices polling strategy: wait 2 seconds before the first poll, then 1 second\n * with an exponential backoff factor of 1.2. Timeout after 5 minutes.\n */\nexport function defaultStrategy(): PollStrategy {\n  return chain(conditionalDelay(once(), 1000), backoff(1000, 1.2), timeout(FIVE_MINUTES_IN_MSEC));\n}\n\n/**\n * Predicate that returns true once.\n */\nexport function once(): Predicate<boolean> {\n  let first = true;\n  return async () => {\n    if (first) {\n      first = false;\n      return true;\n    }\n    return false;\n  };\n}\n\n/**\n * Delay the polling once.\n * @param condition A predicate that indicates when to delay.\n * @param timeInMsec The amount of time to delay.\n */\nexport function conditionalDelay(condition: Predicate<boolean>, timeInMsec: number): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (await condition(canisterId, requestId, status)) {\n      return new Promise(resolve => setTimeout(resolve, timeInMsec));\n    }\n  };\n}\n\n/**\n * Error out after a maximum number of polling has been done.\n * @param count The maximum attempts to poll.\n */\nexport function maxAttempts(count: number): PollStrategy {\n  let attempts = count;\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (--attempts <= 0) {\n      throw new Error(\n        `Failed to retrieve a reply for request after ${count} attempts:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Request status: ${status}\\n`,\n      );\n    }\n  };\n}\n\n/**\n * Throttle polling.\n * @param throttleInMsec Amount in millisecond to wait between each polling.\n */\nexport function throttle(throttleInMsec: number): PollStrategy {\n  return () => new Promise(resolve => setTimeout(resolve, throttleInMsec));\n}\n\n/**\n * Reject a call after a certain amount of time.\n * @param timeInMsec Time in milliseconds before the polling should be rejected.\n */\nexport function timeout(timeInMsec: number): PollStrategy {\n  const end = Date.now() + timeInMsec;\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    if (Date.now() > end) {\n      throw new Error(\n        `Request timed out after ${timeInMsec} msec:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Request status: ${status}\\n`,\n      );\n    }\n  };\n}\n\n/**\n * A strategy that throttle, but using an exponential backoff strategy.\n * @param startingThrottleInMsec The throttle in milliseconds to start with.\n * @param backoffFactor The factor to multiple the throttle time between every poll. For\n *   example if using 2, the throttle will double between every run.\n */\nexport function backoff(startingThrottleInMsec: number, backoffFactor: number): PollStrategy {\n  let currentThrottling = startingThrottleInMsec;\n\n  return () =>\n    new Promise(resolve =>\n      setTimeout(() => {\n        currentThrottling *= backoffFactor;\n        resolve();\n      }, currentThrottling),\n    );\n}\n\n/**\n * Chain multiple polling strategy. This _chains_ the strategies, so if you pass in,\n * say, two throttling strategy of 1 second, it will result in a throttle of 2 seconds.\n * @param strategies A strategy list to chain.\n */\nexport function chain(...strategies: PollStrategy[]): PollStrategy {\n  return async (\n    canisterId: Principal,\n    requestId: RequestId,\n    status: RequestStatusResponseStatus,\n  ) => {\n    for (const a of strategies) {\n      await a(canisterId, requestId, status);\n    }\n  };\n}\n"]}