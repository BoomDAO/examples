{"version":3,"file":"certificate.js","sourceRoot":"","sources":["../../src/certificate.ts"],"names":[],"mappings":"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","sourcesContent":["import * as cbor from './cbor';\nimport { AgentError } from './errors';\nimport { hash } from './request_id';\nimport { concat, fromHex, toHex } from './utils/buffer';\nimport { Principal } from '@dfinity/principal';\nimport * as bls from './utils/bls';\n\n/**\n * A certificate may fail verification with respect to the provided public key\n */\nexport class CertificateVerificationError extends AgentError {\n  constructor(reason: string) {\n    super(`Invalid certificate: ${reason}`);\n  }\n}\n\ninterface Cert {\n  tree: HashTree;\n  signature: ArrayBuffer;\n  delegation?: Delegation;\n}\n\nconst enum NodeId {\n  Empty = 0,\n  Fork = 1,\n  Labeled = 2,\n  Leaf = 3,\n  Pruned = 4,\n}\n\nexport type HashTree =\n  | [NodeId.Empty]\n  | [NodeId.Fork, HashTree, HashTree]\n  | [NodeId.Labeled, ArrayBuffer, HashTree]\n  | [NodeId.Leaf, ArrayBuffer]\n  | [NodeId.Pruned, ArrayBuffer];\n\n/**\n * Make a human readable string out of a hash tree.\n * @param tree\n */\nexport function hashTreeToString(tree: HashTree): string {\n  const indent = (s: string) =>\n    s\n      .split('\\n')\n      .map(x => '  ' + x)\n      .join('\\n');\n  function labelToString(label: ArrayBuffer): string {\n    const decoder = new TextDecoder(undefined, { fatal: true });\n    try {\n      return JSON.stringify(decoder.decode(label));\n    } catch (e) {\n      return `data(...${label.byteLength} bytes)`;\n    }\n  }\n\n  switch (tree[0]) {\n    case NodeId.Empty:\n      return '()';\n    case NodeId.Fork: {\n      const left = hashTreeToString(tree[1]);\n      const right = hashTreeToString(tree[2]);\n      return `sub(\\n left:\\n${indent(left)}\\n---\\n right:\\n${indent(right)}\\n)`;\n    }\n    case NodeId.Labeled: {\n      const label = labelToString(tree[1]);\n      const sub = hashTreeToString(tree[2]);\n      return `label(\\n label:\\n${indent(label)}\\n sub:\\n${indent(sub)}\\n)`;\n    }\n    case NodeId.Leaf: {\n      return `leaf(...${tree[1].byteLength} bytes)`;\n    }\n    case NodeId.Pruned: {\n      return `pruned(${toHex(new Uint8Array(tree[1]))}`;\n    }\n    default: {\n      return `unknown(${JSON.stringify(tree[0])})`;\n    }\n  }\n}\n\ninterface Delegation extends Record<string, any> {\n  subnet_id: ArrayBuffer;\n  certificate: ArrayBuffer;\n}\n\nfunction isBufferEqual(a: ArrayBuffer, b: ArrayBuffer): boolean {\n  if (a.byteLength !== b.byteLength) {\n    return false;\n  }\n  const a8 = new Uint8Array(a);\n  const b8 = new Uint8Array(b);\n  for (let i = 0; i < a8.length; i++) {\n    if (a8[i] !== b8[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\ntype VerifyFunc = (pk: Uint8Array, sig: Uint8Array, msg: Uint8Array) => Promise<boolean>;\n\nexport interface CreateCertificateOptions {\n  /**\n   * The bytes encoding the certificate to be verified\n   */\n  certificate: ArrayBuffer;\n  /**\n   * The root key against which to verify the certificate\n   * (normally, the root key of the IC main network)\n   */\n  rootKey: ArrayBuffer;\n  /**\n   * The effective canister ID of the request when verifying a response, or\n   * the signing canister ID when verifying a certified variable.\n   */\n  canisterId: Principal;\n  /**\n   * BLS Verification strategy. Default strategy uses wasm for performance, but that may not be available in all contexts.\n   */\n  blsVerify?: VerifyFunc;\n}\n\nexport class Certificate {\n  private readonly cert: Cert;\n\n  /**\n   * Create a new instance of a certificate, automatically verifying it. Throws a\n   * CertificateVerificationError if the certificate cannot be verified.\n   * @constructs {@link AuthClient}\n   * @param {CreateCertificateOptions} options\n   * @see {@link CreateCertificateOptions}\n   * @param {ArrayBuffer} options.certificate The bytes of the certificate\n   * @param {ArrayBuffer} options.rootKey The root key to verify against\n   * @param {Principal} options.canisterId The effective or signing canister ID\n   * @throws {CertificateVerificationError}\n   */\n  public static async create(options: CreateCertificateOptions): Promise<Certificate> {\n    let blsVerify = options.blsVerify;\n    if (!blsVerify) {\n      blsVerify = bls.blsVerify;\n    }\n    const cert = new Certificate(\n      options.certificate,\n      options.rootKey,\n      options.canisterId,\n      blsVerify,\n    );\n    await cert.verify();\n    return cert;\n  }\n\n  private constructor(\n    certificate: ArrayBuffer,\n    private _rootKey: ArrayBuffer,\n    private _canisterId: Principal,\n    private _blsVerify: VerifyFunc,\n  ) {\n    this.cert = cbor.decode(new Uint8Array(certificate));\n  }\n\n  public lookup(path: Array<ArrayBuffer | string>): ArrayBuffer | undefined {\n    return lookup_path(path, this.cert.tree);\n  }\n\n  private async verify(): Promise<void> {\n    const rootHash = await reconstruct(this.cert.tree);\n    const derKey = await this._checkDelegationAndGetKey(this.cert.delegation);\n    const sig = this.cert.signature;\n    const key = extractDER(derKey);\n    const msg = concat(domain_sep('ic-state-root'), rootHash);\n    let sigVer = false;\n    try {\n      sigVer = await this._blsVerify(new Uint8Array(key), new Uint8Array(sig), new Uint8Array(msg));\n    } catch (err) {\n      sigVer = false;\n    }\n    if (!sigVer) {\n      throw new CertificateVerificationError('Signature verification failed');\n    }\n  }\n\n  private async _checkDelegationAndGetKey(d?: Delegation): Promise<ArrayBuffer> {\n    if (!d) {\n      return this._rootKey;\n    }\n    const cert: Certificate = await Certificate.create({\n      certificate: d.certificate,\n      rootKey: this._rootKey,\n      canisterId: this._canisterId,\n    });\n\n    const rangeLookup = cert.lookup(['subnet', d.subnet_id, 'canister_ranges']);\n    if (!rangeLookup) {\n      throw new CertificateVerificationError(\n        `Could not find canister ranges for subnet 0x${toHex(d.subnet_id)}`,\n      );\n    }\n    const ranges_arr: Array<[Uint8Array, Uint8Array]> = cbor.decode(rangeLookup);\n    const ranges: Array<[Principal, Principal]> = ranges_arr.map(v => [\n      Principal.fromUint8Array(v[0]),\n      Principal.fromUint8Array(v[1]),\n    ]);\n\n    const canisterInRange = ranges.some(\n      r => r[0].ltEq(this._canisterId) && r[1].gtEq(this._canisterId),\n    );\n    if (!canisterInRange) {\n      throw new CertificateVerificationError(\n        `Canister ${this._canisterId} not in range of delegations for subnet 0x${toHex(\n          d.subnet_id,\n        )}`,\n      );\n    }\n    const publicKeyLookup = cert.lookup(['subnet', d.subnet_id, 'public_key']);\n    if (!publicKeyLookup) {\n      throw new Error(`Could not find subnet key for subnet 0x${toHex(d.subnet_id)}`);\n    }\n    return publicKeyLookup;\n  }\n}\n\nconst DER_PREFIX = fromHex(\n  '308182301d060d2b0601040182dc7c0503010201060c2b0601040182dc7c05030201036100',\n);\nconst KEY_LENGTH = 96;\n\nfunction extractDER(buf: ArrayBuffer): ArrayBuffer {\n  const expectedLength = DER_PREFIX.byteLength + KEY_LENGTH;\n  if (buf.byteLength !== expectedLength) {\n    throw new TypeError(`BLS DER-encoded public key must be ${expectedLength} bytes long`);\n  }\n  const prefix = buf.slice(0, DER_PREFIX.byteLength);\n  if (!isBufferEqual(prefix, DER_PREFIX)) {\n    throw new TypeError(\n      `BLS DER-encoded public key is invalid. Expect the following prefix: ${DER_PREFIX}, but get ${prefix}`,\n    );\n  }\n\n  return buf.slice(DER_PREFIX.byteLength);\n}\n\n/**\n * @param t\n */\nexport async function reconstruct(t: HashTree): Promise<ArrayBuffer> {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return hash(domain_sep('ic-hashtree-empty'));\n    case NodeId.Pruned:\n      return t[1] as ArrayBuffer;\n    case NodeId.Leaf:\n      return hash(concat(domain_sep('ic-hashtree-leaf'), t[1] as ArrayBuffer));\n    case NodeId.Labeled:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-labeled'),\n          t[1] as ArrayBuffer,\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    case NodeId.Fork:\n      return hash(\n        concat(\n          domain_sep('ic-hashtree-fork'),\n          await reconstruct(t[1] as HashTree),\n          await reconstruct(t[2] as HashTree),\n        ),\n      );\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction domain_sep(s: string): ArrayBuffer {\n  const len = new Uint8Array([s.length]);\n  const str = new TextEncoder().encode(s);\n  return concat(len, str);\n}\n\n/**\n * @param path\n * @param tree\n */\nexport function lookup_path(\n  path: Array<ArrayBuffer | string>,\n  tree: HashTree,\n): ArrayBuffer | undefined {\n  if (path.length === 0) {\n    switch (tree[0]) {\n      case NodeId.Leaf: {\n        return new Uint8Array(tree[1]).buffer;\n      }\n      default: {\n        return undefined;\n      }\n    }\n  }\n\n  const label = typeof path[0] === 'string' ? new TextEncoder().encode(path[0]) : path[0];\n  const t = find_label(label, flatten_forks(tree));\n  if (t) {\n    return lookup_path(path.slice(1), t);\n  }\n}\nfunction flatten_forks(t: HashTree): HashTree[] {\n  switch (t[0]) {\n    case NodeId.Empty:\n      return [];\n    case NodeId.Fork:\n      return flatten_forks(t[1] as HashTree).concat(flatten_forks(t[2] as HashTree));\n    default:\n      return [t];\n  }\n}\nfunction find_label(l: ArrayBuffer, trees: HashTree[]): HashTree | undefined {\n  if (trees.length === 0) {\n    return undefined;\n  }\n  for (const t of trees) {\n    if (t[0] === NodeId.Labeled) {\n      const p = t[1] as ArrayBuffer;\n      if (isBufferEqual(l, p)) {\n        return t[2];\n      }\n    }\n  }\n}\n"]}