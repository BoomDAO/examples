{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/canisterStatus/index.ts"],"names":[],"mappings":"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","sourcesContent":["/** @module CanisterStatus */\n\nimport { lebDecode, PipeArrayBuffer } from '@dfinity/candid';\nimport { Principal } from '@dfinity/principal';\nimport { AgentError } from '../errors';\nimport { HttpAgent } from '../agent/http';\nimport { Certificate, CreateCertificateOptions } from '../certificate';\nimport { toHex } from '../utils/buffer';\nimport * as Cbor from '../cbor';\n\n/**\n * Types of an entry on the canisterStatus map.\n * An entry of null indicates that the request failed, due to lack of permissions or the result being missing.\n */\nexport type Status = string | ArrayBuffer | Date | ArrayBuffer[] | Principal[] | bigint | null;\n\n/**\n * Interface to define a custom path. Nested paths will be represented as individual buffers, and can be created from text using {@link TextEncoder}\n */\nexport interface CustomPath {\n  key: string;\n  path: ArrayBuffer[] | string;\n  decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw';\n}\n\n/**\n * Interface to request metadata from the icp:public or icp:private sections.\n * Similar to {@link CustomPath}, but accepts a simple string argument.\n * Private metadata will require the ${@link Identity} used by the ${@link HttpAgent} will need to be requested using an identity that controlls the canister.\n */\nexport interface MetaData {\n  kind: 'metadata';\n  key: string;\n  path: string | ArrayBuffer;\n  decodeStrategy: 'cbor' | 'hex' | 'leb128' | 'utf-8' | 'raw';\n}\n\n/**\n * Pre-configured fields for canister status paths\n */\nexport type Path =\n  | 'time'\n  | 'controllers'\n  | 'subnet'\n  | 'module_hash'\n  | 'candid'\n  | MetaData\n  | CustomPath;\n\nexport type StatusMap = Map<Path | string, Status>;\n\nexport type CanisterStatusOptions = {\n  canisterId: Principal;\n  agent: HttpAgent;\n  paths?: Path[] | Set<Path>;\n  blsVerify?: CreateCertificateOptions['blsVerify'];\n};\n\n/**\n *\n * @param {CanisterStatusOptions} options {@link CanisterStatusOptions}\n * @param {CanisterStatusOptions['canisterId']} options.canisterId {@link Principal}\n * @param {CanisterStatusOptions['agent']} options.agent {@link HttpAgent} optional authenticated agent to use to make the canister request. Useful for accessing private metadata under icp:private\n * @param {CanisterStatusOptions['paths']} options.paths {@link Path[]}\n * @returns {Status} object populated with data from the requested paths\n * @example\n * const status = await canisterStatus({\n *   paths: ['controllers', 'candid'],\n *   ...options\n * });\n *\n * const controllers = status.get('controllers');\n */\nexport const request = async (options: {\n  canisterId: Principal;\n  agent: HttpAgent;\n  paths?: Path[] | Set<Path>;\n}): Promise<StatusMap> => {\n  const { canisterId, agent, paths } = options;\n\n  const uniquePaths = [...new Set(paths)];\n\n  // Map path options to their correct formats\n  const encodedPaths = uniquePaths.map(path => {\n    return encodePath(path, canisterId);\n  });\n  const status = new Map<string | Path, Status>();\n\n  const promises = uniquePaths.map((path, index) => {\n    return (async () => {\n      try {\n        const response = await agent.readState(canisterId, {\n          paths: [encodedPaths[index]],\n        });\n        const cert = await Certificate.create({\n          certificate: response.certificate,\n          rootKey: agent.rootKey,\n          canisterId: canisterId,\n        });\n\n        const data = cert.lookup(encodePath(uniquePaths[index], canisterId));\n        if (!data) {\n          // Typically, the cert lookup will throw\n          console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n          if (typeof path === 'string') {\n            status.set(path, null);\n          } else {\n            status.set(path.key, null);\n          }\n        } else {\n          switch (path) {\n            case 'time': {\n              status.set(path, decodeTime(data));\n              break;\n            }\n            case 'controllers': {\n              status.set(path, decodeControllers(data));\n              break;\n            }\n            case 'module_hash': {\n              status.set(path, decodeHex(data));\n              break;\n            }\n            case 'candid': {\n              status.set(path, new TextDecoder().decode(data));\n              break;\n            }\n            default: {\n              // Check for CustomPath signature\n              if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n                switch (path.decodeStrategy) {\n                  case 'raw':\n                    status.set(path.key, data);\n                    break;\n                  case 'leb128': {\n                    status.set(path.key, decodeLeb128(data));\n                    break;\n                  }\n                  case 'cbor': {\n                    status.set(path.key, decodeCbor(data));\n                    break;\n                  }\n                  case 'hex': {\n                    status.set(path.key, decodeHex(data));\n                    break;\n                  }\n                  case 'utf-8': {\n                    status.set(path.key, decodeUtf8(data));\n                  }\n                }\n              }\n            }\n          }\n        }\n      } catch (error) {\n        // Break on signature verification errors\n        if ((error as AgentError)?.message?.includes('Invalid certificate')) {\n          throw new AgentError((error as AgentError).message);\n        }\n        if (typeof path !== 'string' && 'key' in path && 'path' in path) {\n          status.set(path.key, null);\n        } else {\n          status.set(path, null);\n        }\n        console.group();\n        console.warn(`Expected to find result for path ${path}, but instead found nothing.`);\n        console.warn(error);\n        console.groupEnd();\n      }\n    })();\n  });\n\n  // Fetch all values separately, as each option can fail\n  await Promise.all(promises);\n\n  return status;\n};\n\nexport const encodePath = (path: Path, canisterId: Principal): ArrayBuffer[] => {\n  const encoder = new TextEncoder();\n\n  const encode = (arg: string): ArrayBuffer => {\n    return new DataView(encoder.encode(arg).buffer).buffer;\n  };\n  const canisterBuffer = new DataView(canisterId.toUint8Array().buffer).buffer;\n  switch (path) {\n    case 'time':\n      return [encode('time')];\n    case 'controllers':\n      return [encode('canister'), canisterBuffer, encode('controllers')];\n    case 'module_hash':\n      return [encode('canister'), canisterBuffer, encode('module_hash')];\n    case 'subnet':\n      return [encode('subnet')];\n    case 'candid':\n      return [encode('canister'), canisterBuffer, encode('metadata'), encode('candid:service')];\n    default: {\n      // Check for CustomPath signature\n      if ('key' in path && 'path' in path) {\n        // For simplified metadata queries\n        if (typeof path['path'] === 'string' || path['path'] instanceof ArrayBuffer) {\n          const metaPath = path.path;\n          const encoded = typeof metaPath === 'string' ? encode(metaPath) : metaPath;\n\n          return [encode('canister'), canisterBuffer, encode('metadata'), encoded];\n\n          // For non-metadata, return the provided custompath\n        } else {\n          return path['path'];\n        }\n      }\n    }\n  }\n  throw new Error(\n    `An unexpeected error was encountered while encoding your path for canister status. Please ensure that your path, ${path} was formatted correctly.`,\n  );\n};\n\nconst decodeHex = (buf: ArrayBuffer): string => {\n  return toHex(buf);\n};\n\nconst decodeLeb128 = (buf: ArrayBuffer): bigint => {\n  return lebDecode(new PipeArrayBuffer(buf));\n};\n\nconst decodeCbor = (buf: ArrayBuffer): ArrayBuffer[] => {\n  return Cbor.decode(buf);\n};\n\nconst decodeUtf8 = (buf: ArrayBuffer): string => {\n  return new TextDecoder().decode(buf);\n};\n\n// time is a LEB128-encoded Nat\nconst decodeTime = (buf: ArrayBuffer): Date => {\n  const decoded = decodeLeb128(buf);\n  return new Date(Number(decoded / BigInt(1_000_000)));\n};\n\n// Controllers are CBOR-encoded buffers, starting with a Tag we don't need\nconst decodeControllers = (buf: ArrayBuffer): Principal[] => {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const [tag, ...controllersRaw] = decodeCbor(buf);\n  return controllersRaw.map((buf: ArrayBuffer) => {\n    return Principal.fromUint8Array(new Uint8Array(buf));\n  });\n};\n"]}