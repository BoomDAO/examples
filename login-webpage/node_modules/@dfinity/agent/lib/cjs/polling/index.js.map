{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/polling/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { Principal } from '@dfinity/principal';\nimport { Agent, RequestStatusResponseStatus } from '../agent';\nimport { Certificate, CreateCertificateOptions } from '../certificate';\nimport { RequestId } from '../request_id';\nimport { toHex } from '../utils/buffer';\n\nexport * as strategy from './strategy';\nexport { defaultStrategy } from './strategy';\nexport type PollStrategy = (\n  canisterId: Principal,\n  requestId: RequestId,\n  status: RequestStatusResponseStatus,\n) => Promise<void>;\nexport type PollStrategyFactory = () => PollStrategy;\n\n/**\n * Polls the IC to check the status of the given request then\n * returns the response bytes once the request has been processed.\n * @param agent The agent to use to poll read_state.\n * @param canisterId The effective canister ID.\n * @param requestId The Request ID to poll status for.\n * @param strategy A polling strategy.\n * @param request Request for the readState call.\n */\nexport async function pollForResponse(\n  agent: Agent,\n  canisterId: Principal,\n  requestId: RequestId,\n  strategy: PollStrategy,\n  // eslint-disable-next-line\n  request?: any,\n  blsVerify?: CreateCertificateOptions['blsVerify'],\n): Promise<ArrayBuffer> {\n  const path = [new TextEncoder().encode('request_status'), requestId];\n  const currentRequest = request ?? (await agent.createReadStateRequest?.({ paths: [path] }));\n  const state = await agent.readState(canisterId, { paths: [path] }, undefined, currentRequest);\n  if (agent.rootKey == null) throw new Error('Agent root key not initialized before polling');\n  const cert = await Certificate.create({\n    certificate: state.certificate,\n    rootKey: agent.rootKey,\n    canisterId: canisterId,\n    blsVerify,\n  });\n  const maybeBuf = cert.lookup([...path, new TextEncoder().encode('status')]);\n  let status;\n  if (typeof maybeBuf === 'undefined') {\n    // Missing requestId means we need to wait\n    status = RequestStatusResponseStatus.Unknown;\n  } else {\n    status = new TextDecoder().decode(maybeBuf);\n  }\n\n  switch (status) {\n    case RequestStatusResponseStatus.Replied: {\n      return cert.lookup([...path, 'reply'])!;\n    }\n\n    case RequestStatusResponseStatus.Received:\n    case RequestStatusResponseStatus.Unknown:\n    case RequestStatusResponseStatus.Processing:\n      // Execute the polling strategy, then retry.\n      await strategy(canisterId, requestId, status);\n      return pollForResponse(agent, canisterId, requestId, strategy, currentRequest);\n\n    case RequestStatusResponseStatus.Rejected: {\n      const rejectCode = new Uint8Array(cert.lookup([...path, 'reject_code'])!)[0];\n      const rejectMessage = new TextDecoder().decode(cert.lookup([...path, 'reject_message'])!);\n      throw new Error(\n        `Call was rejected:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n` +\n          `  Reject code: ${rejectCode}\\n` +\n          `  Reject text: ${rejectMessage}\\n`,\n      );\n    }\n\n    case RequestStatusResponseStatus.Done:\n      // This is _technically_ not an error, but we still didn't see the `Replied` status so\n      // we don't know the result and cannot decode it.\n      throw new Error(\n        `Call was marked as done but we never saw the reply:\\n` +\n          `  Request ID: ${toHex(requestId)}\\n`,\n      );\n  }\n  throw new Error('unreachable');\n}\n"]}